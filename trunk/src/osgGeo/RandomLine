#ifndef OSGGEO_RANDOMLINE_H
#define OSGGEO_RANDOMLINE_H

/* osgGeo - A collection of geoscientific extensions to OpenSceneGraph.
Copyright 2011 dGB Beheer B.V.

osgGeo is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>

$Id$

*/

#include <osg/Node>
#include <osg/Array>
#include <osg/NodeVisitor>
#include <osgGeo/Common>


namespace osg { class Geometry; class Geode; }

namespace osgGeo
{
class LayeredTexture;

/*!Class to display a random section through a 3d volume with a texture. The
    section follows a path on the xy plane, and starts/stops at the
    z-coordinates given by setZrange.
*/

class OSGGEO_EXPORT RandomLineNode : public osg::Node
{
public:

				RandomLineNode();
				RandomLineNode(const RandomLineNode&,
				    const osg::CopyOp& op =
				    osg::CopyOp::DEEP_COPY_ALL);
				META_Node(osgGeo,RandomLineNode);
    
    void			setTexture(osgGeo::LayeredTexture*);
    osgGeo::LayeredTexture*	getTexture()		{ return _texture; }
    
    void			setPath(const osg::Vec2Array& coords,
				     const osg::UIntArray& indices);
				/*!<Sets the path. The indices corresponds to
				    columns in the texture, so the texture will
				    be in sync with the path. */
				     
    const osg::UIntArray&	getKnotIndices() const	{ return *_pathindices;}
    const osg::Vec2Array&	getKnotCoords() const	{ return *_pathcoords; }
    
    void			setZRange(float top, float bottom );
    float			getBottom() const	{ return _bottom; }
    float			getTop() const		{ return _top; }
    
protected:
    virtual			~RandomLineNode();
    bool			updateGeometry();
    void			traverse(osg::NodeVisitor&);
    
    osg::ref_ptr<osgGeo::LayeredTexture>	_texture;
    osg::ref_ptr<osg::UIntArray>		_pathindices;
    osg::ref_ptr<osg::Vec2Array>		_pathcoords;
    float					_top;
    float					_bottom;
    osg::ref_ptr<osg::Geode>			_geode;
    int						_updatecount;
    int						_lastgeomupdatecount;
};



}
#endif //OSGGEO_RANDOMLINE_H

